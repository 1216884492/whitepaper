%% Based on the style files for ACL-2015

\documentclass[11pt]{article}
\usepackage{acl2015}

\title{The Keep Network:\protect\\A Privacy Layer for Public Blockchains}

\author{Matt Luongo \\
  {\tt mhluongo@gmail.com}}

\date{}

\begin{document} \maketitle \begin{abstract}

  We introduce the keep, a new privacy primitive for smart contracts
  on public blockchains, as well as supporting components, including
  the keep market and token, that make up the Keep network.

  Rather than aiming to solve generic private smart contracts with an
  alternative computation network, we present an incremental approach
  that can be brought to market on the Ethereum public network,
  iterated on, and adapted for other public blockchains and
  cross-blockchain use.

\end{abstract}

\section{Motivation}

\subsection{The irony of public blockchains}

Public blockchains have brought unprecedented transparency and
auditability to financial technology. Records are immutable,
verifiable, and censorship-resistant.

Unfortunately, these strengths are also weaknesses for many potential
users.

For every financial use case a public blockchain enables, its public
status restricts another. Bitcoin is touted as a more private payment
method than the traditional financial system, but those familiar with
the technology know that while it may be censorship-resistant, it’s
certainly not private by default \cite{bitcoinPrivacy}. Developers
introduced to Ethereum quickly learn to adjust their expectations
\cite{ethereumStackexchange}- all contract state is published to the
blockchain, and can be easily read by competing interests.

These issues are recognized by developers of the Bitcoin and Ethereum
projects. Confidential transactions \cite{confidentialTransactions} is
an ongoing effort to bring better privacy, and therefore fungibility,
to Bitcoin. As early as December 2014, Vitalik Buterin, one of the
founders of Ethereum, explored solving this problem with secure multi
party computation (sMPC) \cite{secretSharingDaos}. In more recent
writing, Buterin shares that “...when [he] and others talk to
companies about building their applications on a blockchain, two
primary issues always come up: scalability and privacy”
\cite{privacyOnTheBlockchain}.

Scalability of public blockchains is a hurdle to mainstream adoption.
Some of the best minds in the cryptocurrency space \cite{lightning}
\cite{ethereumSharding} \cite{plasma} are working on multiple
order-of-magnitude improvements. Privacy, however, hasn’t garnered the
same attention, especially in smart contracts.

Basic use cases of smart contracts, including publishing secrets after
certain criteria are met, assessing borrower risk for a loan, and
verifying real-world identity on the blockchain, are incredibly
difficult on today’s public blockchains.

\section{Introducing keeps}

To solve this mismatch between the transparency of public blockchains,
and the need of many smart contracts for private data, we introduce
the idea of {\em keeps}.

A keep is an off-chain container for private data. Keeps allow
contracts to manage and use private data without exposing the data to
the public blockchain.

\subsection{Keep operations}

\subsubsection{Creation and population}

Contracts request a keep by publishing a record to the blockchain.
Once a keep is created off-chain, it will respond with a set of public
keys the calling contract can use to communicate privately with the
keep.

Once the keep has been created, it can be populated in a number of
ways. dApps can publish secret data to the blockchain, encrypted by
the keep’s public keys, or send the data to the keep off-chain.
Alternatively, a keep can self-populate with pseudorandom data.

\subsubsection{Publishing data on-chain}

The most useful function of a keep is to publish or otherwise make use
of its secret.

Initially, keeps will only support publishing their secrets on-chain.
Contracts can request a keep to publish a secret in the clear or
encrypted with a provided public key. This allows keeps to provide
functionality that’s difficult in today’s public smart contracts, like
a secret-exposing dead man switch, useful in a variety of
decentralized market schemes.

Keeps can be extended to use their secret in a variety of other ways,
including as a key for symmetric encryption and signing.

\subsubsection{Access management}

The creator of a keep can delegate access to the keep.

Read and management access can each be granted to contracts, allowing
another contract to request that a keep’s content be published, or to
delegate further access to other contracts. Creators can also remove
their own access.

Access management  enables multi-party secret escrow and auditability
of secret access.

\subsubsection{Destruction}

Keeps can be long- or short-lived. Contracts can request that a keep
be shut down, and should also handle keeps being terminated
unexpectedly. Note that although keeps can be shut down, there can be
no guarantees that a secret wasn’t persisted- instead, we rely on
other confidentiality guarantees, covered later in the paper.

\section{Managing third-party risk}

We’ve described a simple black box for off-chain data storage. The
standardization of this method of secret management will enable
secrets to be bought, sold, and transferred on a public blockchain,
but don’t solve third-party risks.

Next, we’ll go over how the need for a trusted third party can be
eliminated.

\subsection{Secure multi party computation}

Secure multi party computation (sMPC) is a type of cryptographic
system where a computation is distributed across multiple
participants, some of which may be dishonest. Each participant is
initially given access to a share of a secret by a dealer, and
computes a function over that share. The outputs are then reported to
the dealer, who can assemble the final output, without any participant
learning more than their initial secret share.

Recent sMPC approaches only maintain security in the face of an honest
majority. However, by using a public blockchain as an immutable
ledger, sMPC can be made secure in the face of a dishonest
supermajority \cite{spdz}, and with the requirement of a network
token, can be made strongly Sybil-resistant \footnote{Refer to
"Incentivizing keep providers" for more details}.

For these reasons, sMPC and blockchains are a natural fit. In the
smart contract space, sMPC has been proposed before as a privacy
mechanic.

In 2014, Vitalik Buterin gave a strong introduction to the subject in
an early blog post on privacy on the Ethereum public blockchain
\cite{secretSharingDaos}. In 2016, a team from UMD designed Hawk
\cite{hawk}, a system that marries public and private smart contracts
via sMPC, and the Enigma project out of MIT describes a system related
to ours \cite{enigma}, with a wider focus on general private
computation.

The Keep network will incorporate these ideas into the first
production-ready sMPC system for a public blockchain.

\section{Keep providers}

The Keep network includes a number of different provider types, each
with their own strengths and tradeoffs. The most important provider,
however, is a novel application of secure multi party computation.

\subsection{Simple sMPC}

Simple sMPC keeps are backed by n nodes, each of which maintain a
share of the provided secret, such that the secret can’t be
reconstructed without all n nodes colluding.

These keeps can be populated securely by divvying up a secret into
shares via Shamir secret sharing \cite{shamir}, and encrypting each
share with its respective node’s public key. The encrypted shares can
then be published to the public blockchain, or communicated off-chain.

The only computation these keeps will run is an implementation of
distributed RSA \cite{mauland2009realizing} on sMPC, used to publish
encrypted data to the blockchain.


\subsection{Signing sMPC}

The next provider will extend the sMPC keep with two new operations-
securely generating pseudorandom numbers, and signing and encrypting
data, using the keep’s contents as a key.

In addition to simple pseudorandom numbers, signing keeps will be able
to generate RSA \cite{mauland2009realizing} and Bitcoin key pairs
\cite{coinparty}, or be populated with them via secret sharing.

This means signing keeps will be able to sign and secure contract
communications on- and off-chain, as well as sign transactions for
Bitcoin, Ethereum, and other cryptocurrencies.

Finally, signing keeps can act as pRNG oracles, significantly
improving current methods of random number generation on public
blockchains.


\subsection{Trusted third-party}

The third provider is the simplest, and offers fewer security
guarantees. Trusted third-party (TTP) keeps are backed by a single
node, which has full access to secret material. These keeps are
suitable for lower-value on-chain applications, and will be less
expensive than sMPC-backed keeps. Consider, for example, a game with
an on-chain component that needs a secret, or a key protecting an
asset with zero marginal cost to produce.

TTP keeps can be populated simply by publishing the initial data
on-chain, encrypted with the keep’s public key.


\subsubsection{Redundant trusted third-party}

Redundant trusted third-party (RTTP) keeps are a generalization of TTP
keeps, composed of n nodes that are each given a copy of the secret.
RTTP keeps can use a higher n for better availability and data
integrity guarantees, at the expense of confidentiality.

\subsection{Future providers}

Other keep providers are an area for future work.

Unlike related work on systems like Enigma \cite{enigma} or Hawk
\cite{hawk}, which use sMPC to build  off-chain and alternative-chain
computation networks for private smart contracts, we’ve chosen to
restrict the Simple  and Signing sMPC keeps to merely generating,
securing, storing, encrypting, and transmitting secrets.  Such
restrictions help to minimize the attack surface on keeps in a
production network.

In later work, sMPC schemes can be used to build more feature-rich
keeps. These keeps will enable complex use cases, like operating
private ledgers operating on public blockchains, or running
third-party code trustlessly on private data.

The off-chain keep pattern is also flexible enough to include a
variety of other providers, each with their own unique benefits-
including using secure or otherwise specialized hardware.


\section{Incentivizing keep providers}

Providers need to be incentivized to maintain capacity on the network.
Running and securing keeps should be a profitable way to use excess
compute and storage resources.

Consumer contracts, on the other hand, need keeps that will

\begin{itemize} \item Be highly available and robust against data loss
\item Maintain confidentiality and data integrity \end{itemize}

\subsection{Paying for keeps}

The best payment structure for keep providers will reward highly
available keeps, and punish poor performance.

<sequence diagram of deposit + per-operation payment>

The two primary costs providers incur are storage and compute, which
map naturally to paying keeps per block and per operation.

Payment per block can be accomplished via a deposit to the managing
contract at the time of keep initialization, metered out over the
lifetime of the keep, and refilled occasionally by the calling
contract. Though this seems like a good fit for payment channels,
minimizing on-chain fees, the security ramifications differ from
typical two-party channels. These differences are discussed further in
the next section.

Payment per operation is simpler. Each request to publish a keep’s
contents will require payment of an amount agreed to at the
initialization of a keep.

\subsection{Concerns with uptimes and reliability}

Because availability is vital to using keeps in practice, improper
termination must be disincentivized.

<proper shutdown protocol>

Any keep that doesn’t respond properly within a certain block count
threshold to a request will be considered aborted. Aborted keeps will
forfeit all client deposits that have yet to be disbursed. To avoid
skewing client incentives, the deposits that have been earned, but not
yet disbursed, will be burned, and the unearned deposits will be
returned to the client.

Volatility in the crypto currency markets can provide a strong
incentive for a keep provider to improperly terminate a keep. If the
value of the paid currency drops significantly relative to the cost of
running a keep, it’s in a provider’s best interest to devote their
limited resources to a better-paying client.

To counter this issue, keep providers will need a protocol to
optionally re-negotiate fees for a running keep.

\subsection{Concerns with active attacks}

Existing open-source sMPC frameworks, such as VIFF \cite{viff}, are
secure against active attacks in the presence of a ¾ supermajority of
honest nodes. In such an attack, keeps can be forced to return
malformed data, but secrets can’t be compromised unless all nodes with
a unique share backing an sMPC keep are colluding- an extremely high
bar for a Sybil attack.

Recent approaches using SPDZ proofs \cite{spdz} anchored on the
blockchain \cite{bitcoinSmpc} \cite{blockchainMultipartyComputation}
make such correctness attacks impossible, even if all nodes backing a
keep are compromised. sMPC and trusted third-party keeps will publish
proofs to the public blockchain that can be used to verify
correctness. The threat of active attacks is then reduced to
disrupting keep availability, rather than returning malformed data.

We address the issue of network disruption by introducing two
incentives to keep providers, making active attacks on data
availability impractically expensive.

First, keep providers will be required to prove their holdings in a
token native to the system. Significant disruption of the network
should lead to a drop in the value of the token, incentivizing
provider honesty, lest they devalue their holdings. This scheme also
provides resistance to Sybil attacks- an active attacker would need to
obtain an outsize portion of all tokens locked up by keep providers to
ensure their overwhelming selection backing new keeps.

Second, keep redundancy can be used to further minimize availability
disruptions \cite{blockchainMultipartyComputation}. All nodes can be
required to include a deposit when they publish their results. If
their results can’t be verified by the included SPDZ proof, their
deposit is forfeit to competing nodes.  This idea can be generalized
to work with RTTP and sMPC keeps.

\section{High-level network design}

To bring these components together into a functional network,
initially built against the Ethereum blockchain, we’ll introduce a few
more ideas.

\subsection{The keep market}

Different keep types will naturally incur different costs, and offer
differing guarantees and functionality to contract developers. At a
given time, the capacity available on the keep network will also be
limited capacity.. For this reason, a market will need to be developed
that matches keep providers to contracts based on bids for price per
block, price per operation, and required functionality.

\subsection{The Keep network token}

The native network token will be required for providers to participate
in the keep market. Requiring a native token, rather than the
underlying blockchain’s currency, means providers will suffer from
negative externalities in the presence of malicious behavior.

Keep operations can be paid for with the native token, or with the
underlying blockchain’s currency, based on the keep market.

\subsection{The result registry}

Keeps will offer a number of methods to publish to the public
blockchain. In the case where keeps publish to a smart contract
provided by the keep owner, coordination is simple. In uses that don’t
have a natural contract to communicate with, a result registry will be
provided as a default to simplify keep and owner coordination.

\section{Applications}

\subsection{Dead man switch}

A dead man switch is a device that is automatically activated in case
its owner becomes incapacitated. Keeps enable a particular kind of
dead man switch- publishing a secret, under certain contract
conditions.

Examples of dead man switch applications with keeps include automated
inheritance (“send my heir my private key if I don’t check in
quarterly”), arbitration with time limits (“if no decision is made in
10 blocks, publish a shared secret”), as well as protection for
leakers (“publish a key to these insurance files if I don’t check
in”).

\subsection{Marketplaces for digital goods}

Buying and selling digital goods on public blockchains often requires
settling off-chain. Keeps make marketplaces for digital goods, like
audio and video files, straightforward.

Before the Keep network, buying and selling audio files on a public
blockchain might look something like this.

First, the buyer and seller must agree to terms, including an
arbitrator. The funds are escrowed, and the symmetric key protecting
the audio file is encrypted with the buyer’s public key, and published
on-chain with a hash of the cleartext key. If the buyer can access the
file, they release the escrowed funds- otherwise, the arbitrator
decides who gets the funds.

To give the arbitrator access to the file, the buyer publishes the
key, this time encrypted with the arbitrator’s public key. The
arbitrator then decides where to disburse the funds.

We’ve skipped a few steps for simplicity, but some of the issues
should be clear. More robust escrow and arbitration schemes require
${n^2}$ on-chain transactions, and buying and selling private
information requires that any recipient access the digital good in the
clear to confirm a trade.

Keeps improve this situation by encapsulating the secret, and
providing easily auditable access logs. Keeps simplify complex escrow
scenarios, and allow resale of digital goods without unnecessarily
exposing all parties to the secret in the clear.

\subsection{Pseudorandomness Oracle}

Since keeps can populate themselves with random data, they can act as
pseudorandomness oracles, improving on currently popular methods
\cite{prngStackexchange}. sMPC and other secure keeps are a good fit for
decentralized lotteries and other games of chance, as well as offering
a building block for other on-chain algorithms that require
tamper-resistant pRNG.

This capability is an important component of advanced keep users, like
decentralized signing.

\subsection{Decentralized signing service}

Future keep providers will be able to sign messages, including
blockchain transactions, using a generated private key.

A decentralized signing service can participate in multi-sig
transactions, only signing transactions that follow a strict set of
rules, including daily spending limits and recipient whitelists. Such
a service can also be used as a second-factor authentication provider,
answer a challenge-response protocol under certain network conditions.

\subsection{Encryption service for blockchain storage}

Services like Filecoin \cite{filecoin} and Storj \cite{storj} are
being built to provide cheap, ubiquitous storage, accessible globally,
via smart contracts and traditional storage interfaces.

These services offer few privacy guarantees, leaving the onus of file
encryption on users. Keeps can provide a private bridge to blockchain
storage. By generating an AES key at keep initialization and providing
off-chain data access to the keep, smart contracts can use keeps to
secure files stored on Filecoin.

\subsection{Banking on public blockchains}

As more keep providers are developed, more applications that once
required a private blockchain can be built against public networks.

Traditional finance offers many examples. Consider lending, a basic
service provided by most banks.

There are a number of sensitive variables involved in the lending
process. Borrower credit scores are sensitive; risk assessment is
highly competitive; the terms of a loan aren’t typically made public.

Keep providers that execute generic private smart contracts can
protect scores and the risk assessment process, while maintaining
auditability and all other benefits of a public blockchain.

\bibliographystyle{unsrt}
\bibliography{keep}

\end{document}
